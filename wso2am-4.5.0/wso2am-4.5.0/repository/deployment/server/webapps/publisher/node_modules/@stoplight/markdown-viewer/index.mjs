import { useId, Link, Heading, LinkHeading, Callout, Image, ProductImage, AspectRatio, Code, InvertTheme, Tabs, TabList, Tab, TabPanels, TabPanel, Box, Flex, Icon, Popover, Button, Prose } from '@stoplight/mosaic';
import { ErrorBoundary } from '@stoplight/react-error-boundary';
import * as React from 'react';
import React__default, { useMemo, createElement, Fragment } from 'react';
import { parse as parse$1, remarkParsePreset } from '@stoplight/markdown';
import { CodeViewer } from '@stoplight/mosaic-code-viewer';
import deepmerge from 'deepmerge';
import { sanitize as sanitize$1, defaultSchema } from 'hast-util-sanitize';
import remarkParse from 'remark-parse';
import unified from 'unified';
import { u } from 'unist-builder';
import { raw } from 'hast-util-raw';
import { toH } from 'hast-to-hyperscript';
import { visit } from 'unist-util-visit';
import { toHast } from 'mdast-util-to-hast';
import { h } from 'hastscript';
import { selectAll } from 'unist-util-select';
import useComponentSize from '@rehooks/component-size';

const EMPTY_OBJ$4 = {};
const useMarkdown2Mdast = (markdownOrTree, opts = EMPTY_OBJ$4) => {
    return React__default.useMemo(() => {
        const options = {
            components: opts.components,
            remarkPlugins: opts.remarkPlugins,
            settings: opts.settings,
        };
        if (typeof markdownOrTree === 'string') {
            return parse$1(markdownOrTree, options);
        }
        return markdownOrTree;
    }, [markdownOrTree, opts.components, opts.remarkPlugins, opts.settings]);
};

const EMPTY_OBJ$3 = {};
const defaultContext = EMPTY_OBJ$3;
const MarkdownViewerContext = React__default.createContext(undefined);
MarkdownViewerContext.displayName = 'MarkdownViewerContext';
const useMarkdownViewer = () => { var _a; return (_a = React__default.useContext(MarkdownViewerContext)) !== null && _a !== void 0 ? _a : defaultContext; };
const MarkdownViewerProvider = ({ children, components = EMPTY_OBJ$3, ...value }) => {
    const parentValue = useMarkdownViewer();
    const parentComponents = parentValue.components || EMPTY_OBJ$3;
    const newComponents = useMemo(() => Object.assign({}, parentComponents, components), [components, parentComponents]);
    const newContextValue = useMemo(() => Object.assign({}, parentValue, { components: newComponents }, value), [newComponents, parentValue, value]);
    return React__default.createElement(MarkdownViewerContext.Provider, { value: newContextValue }, children);
};

const isServer = typeof document === 'undefined';
const loadMermaid = (id, scriptUrl) => {
    if (isServer)
        return;
    const existing = document.head.querySelector('#' + id);
    if (!existing) {
        const scriptNode = document.createElement('script');
        scriptNode.src = scriptUrl;
        scriptNode.id = id;
        scriptNode.crossOrigin = '';
        document.body.appendChild(scriptNode);
        scriptNode.onload = () => {
            const m = mermaid;
            if (m) {
                m.initialize({
                    startOnLoad: false,
                    sequence: { diagramPadding: 0, showSequenceNumbers: true },
                    er: { diagramPadding: 0 },
                    flowchart: { diagramPadding: 0 },
                    journey: { diagramPadding: 0 },
                });
                m.parseError = function (err) {
                    console.error(`Mermaid parsing error: ${String(err)}`, err);
                };
                document.dispatchEvent(new CustomEvent('mermaid.loaded'));
            }
            else {
                console.warn(`Could not load mermaid.js script from ${scriptUrl}`);
            }
        };
    }
};
let loaded = false;
const useLoadMermaid = (scriptUrl) => {
    if (!loaded) {
        loaded = true;
        loadMermaid('mermaid-loader', scriptUrl);
    }
};

const DEFAULT_MERMAID_SCRIPT_URL = 'https://unpkg.com/mermaid@9.4.3/dist/mermaid.min.js';
const useRenderMermaid = (id, chartValue, containerRef, loaded) => {
    const { mermaidScriptUrl = DEFAULT_MERMAID_SCRIPT_URL } = useMarkdownViewer();
    useLoadMermaid(mermaidScriptUrl);
    React.useEffect(() => {
        const mermaid = window.mermaid;
        if (loaded && mermaid && containerRef.current) {
            mermaid.render(id, chartValue, (el) => {
                if (containerRef.current) {
                    containerRef.current.innerHTML = el;
                }
            }, containerRef.current);
        }
    }, [chartValue, containerRef, id, loaded]);
};

let mermaidLoaded = false;
const MermaidBlock = ({ chartValue }) => {
    const id = useId();
    const containerRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(mermaidLoaded);
    useRenderMermaid(id, chartValue, containerRef, loaded);
    React.useEffect(() => {
        if (!mermaidLoaded) {
            const handler = () => {
                mermaidLoaded = true;
                setLoaded(true);
            };
            document.addEventListener('mermaid.loaded', handler);
            return () => document.removeEventListener('mermaid.loaded', handler);
        }
        return;
    }, []);
    return (React.createElement("div", { className: "mermaid", ref: containerRef }, chartValue));
};

const getCodeLanguage = (lang) => {
    switch (lang) {
        case 'http':
            return 'yaml';
        default:
            return lang;
    }
};

const DefaultSMDComponents = {
    a: ({ href, color, ...props }) => {
        if (typeof href !== 'string')
            return null;
        if (href.startsWith('/') || href.startsWith('#')) {
            return React__default.createElement(Link, { href: href, color: color, ...props });
        }
        return React__default.createElement(Link, { href: href, color: color, target: "_blank", rel: "noopener noreferrer", ...props });
    },
    h1: ({ color, ...props }) => React__default.createElement(Heading, { size: 1, ...props }),
    h2: ({ color, ...props }) => React__default.createElement(LinkHeading, { size: 2, ...props }),
    h3: ({ color, ...props }) => React__default.createElement(LinkHeading, { size: 3, ...props }),
    h4: ({ color, ...props }) => React__default.createElement(LinkHeading, { size: 4, ...props }),
    h5: ({ color, ...props }) => React__default.createElement(Heading, { size: 4, ...props }),
    h6: ({ color, ...props }) => React__default.createElement(Heading, { size: 4, ...props }),
    blockquote: ({ theme, children }) => {
        let intent = 'default';
        if (theme !== 'info')
            intent = theme;
        return (React__default.createElement(Callout, { appearance: "outline", intent: intent, as: "blockquote" }, children));
    },
    img: ({ src, color: _color, bg, focus, inline, invertOnDark, ...props }) => {
        if (!src) {
            console.warn('[MarkdownViewer]: img skipped because `src` is empty.');
            return null;
        }
        if (inline !== void 0 || focus === 'false' || 'style' in props) {
            return React__default.createElement(Image, { src: src, ...props, invertOnDark: invertOnDark !== void 0 });
        }
        return (React__default.createElement(ProductImage, { bg: bg, focus: focus },
            React__default.createElement(Image, { src: src, ...props, invertOnDark: invertOnDark !== void 0 })));
    },
    iframe({ src, ...props }) {
        if (src === null || src === void 0 ? void 0 : src.startsWith('https://open.spotify.com/embed')) {
            return React__default.createElement("iframe", { src: src, ...props, style: { height: src.includes('playlist') ? '400px' : '250px' } });
        }
        return (React__default.createElement(AspectRatio, { ratio: 16 / 9 },
            React__default.createElement("iframe", { src: src, ...props })));
    },
    code: ({ children, inline, lineNumbers, title, lang, ...rest }) => {
        if (inline !== void 0) {
            return React__default.createElement(Code, null, children);
        }
        if (lang === 'mermaid') {
            const chartValue = String(Array.isArray(children) ? children[0] : children);
            return (React__default.createElement(ErrorBoundary, null,
                React__default.createElement(MermaidBlock, { chartValue: chartValue })));
        }
        return (React__default.createElement(ErrorBoundary, null,
            React__default.createElement(InvertTheme, null,
                React__default.createElement(CodeViewer, { bg: "canvas", value: String(children), language: getCodeLanguage(String(lang)), rounded: "lg", ring: { focus: true }, ringColor: "primary", ringOpacity: 50, showLineNumbers: lineNumbers !== void 0, title: title, ...rest }))));
    },
    tabs: props => {
        return (React__default.createElement(Tabs, { appearance: "line" },
            React__default.createElement(TabList, null, React__default.Children.map(props.children, (child, i) => (React__default.createElement(Tab, { key: i }, child.props.title)))),
            React__default.createElement(TabPanels, null, React__default.Children.map(props.children, (child, i) => (React__default.createElement(TabPanel, { key: i }, child))))));
    },
    tab: ({ children }) => React__default.createElement(React__default.Fragment, null, children),
    codegroup: props => {
        return (React__default.createElement(Box, { className: "sl-code-group" },
            React__default.createElement(Tabs, null,
                React__default.createElement(Flex, { alignItems: "center" },
                    React__default.createElement(Box, { mr: 4, ml: 1 },
                        React__default.createElement(Icon, { icon: ['far', 'code'], size: "sm" })),
                    React__default.createElement(TabList, { fontSize: "lg", density: "compact" }, React__default.Children.map(props.children, (child, i) => {
                        var _a;
                        return React__default.createElement(Tab, { key: i }, ((_a = child.props) === null || _a === void 0 ? void 0 : _a.lang) || 'untitled');
                    }))),
                React__default.createElement(TabPanels, { p: 1 }, React__default.Children.map(props.children, (child, i) => (React__default.createElement(TabPanel, { key: i }, child)))))));
    },
};

function rehypeRaw(options, _settings) {
    return transform;
    function transform(tree, file) {
        return raw(tree, file, options);
    }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var hastCssPropertyMap = {
    align: 'text-align',
    valign: 'vertical-align',
    height: 'height',
    width: 'width',
};
function tableCellStyle(node) {
    visit(node, 'element', visitor);
    return node;
}
function visitor(node) {
    if (node.tagName !== 'tr' && node.tagName !== 'td' && node.tagName !== 'th') {
        return;
    }
    var hastName;
    var cssName;
    for (hastName in hastCssPropertyMap) {
        if (!hasOwnProperty.call(hastCssPropertyMap, hastName) || node.properties[hastName] === undefined) {
            continue;
        }
        cssName = hastCssPropertyMap[hastName];
        appendStyle(node, cssName, node.properties[hastName]);
        delete node.properties[hastName];
    }
}
function appendStyle(node, property, value) {
    var prevStyle = (node.properties.style || '').trim();
    if (prevStyle && !/;\s*/.test(prevStyle)) {
        prevStyle += ';';
    }
    if (prevStyle) {
        prevStyle += ' ';
    }
    var nextStyle = prevStyle + property + ': ' + value + ';';
    node.properties.style = nextStyle;
}

var own = {}.hasOwnProperty;
function rehypeReact(options) {
    var settings = options || {};
    var createElement = settings.createElement;
    this.Compiler = compiler;
    function compiler(node) {
        var result = toH(h, tableCellStyle(node), settings.prefix);
        if (node.type === 'root') {
            result =
                result.type === 'div' && (node.children.length !== 1 || node.children[0].type !== 'element')
                    ? result.props.children
                    : [result];
            return createElement(settings.Fragment || 'div', {}, result);
        }
        return result;
    }
    function h(name, props, children) {
        var component = name;
        if (settings.components && own.call(settings.components, name)) {
            component = settings.components[name];
            if (settings.passNode) {
                props.node = this;
            }
        }
        return createElement(component, props, children);
    }
}

function remark2rehype(destination, options) {
    if (destination && !destination.process) {
        options = destination;
        destination = null;
    }
    return destination ? bridge(destination, options) : mutate(options);
}
function bridge(destination, options) {
    return transformer;
    function transformer(node, file, next) {
        destination.run(toHast(node, options), file, done);
        function done(error) {
            next(error);
        }
    }
}
function mutate(options) {
    return transformer;
    function transformer(node) {
        return toHast(node, options);
    }
}

function createIframeNode(props) {
    return h('iframe', {
        ...props,
        seamless: true,
        style: 'width: 100%',
        width: '100%',
    });
}

var customProviders = [
    {
        provider_name: 'CodePen',
        provider_url: 'https://codepen.io',
        handler(href) {
            if (!href.includes('/pen/'))
                return;
            return createIframeNode({
                sandbox: 'allow-scripts allow-same-origin',
                src: href.replace('/pen/', '/embed/'),
            });
        },
    },
    {
        provider_name: 'GitHub',
        provider_url: 'https://gist.github.com',
        handler(href) {
            if (href === 'https://gist.github.com' || href === 'https://gist.github.com/discover')
                return;
            return createIframeNode({
                srcdoc: `<script src="${href}.js"></script>
<script>
  const style = document.body.appendChild(document.createElement('style'));
  style.textContent = \`body { margin: 0; }
.gist .gist-file { margin-bottom: 0 !important; \`;
  const offsetHeight = document.querySelector('.gist').offsetHeight;
  window.frameElement.parentElement.style.height = \`\${offsetHeight}px\`;
</script>`,
            });
        },
    },
    {
        provider_name: 'GIPHY',
        provider_url: 'https://giphy.com',
        handler(href) {
            const i = href.lastIndexOf('-');
            if (i === -1)
                return;
            const id = href.slice(i + 1);
            return createIframeNode({
                src: `https://giphy.com/embed/${id}${href.includes('/clips/') ? '/video' : ''}`,
            });
        },
    },
    {
        provider_name: 'Spotify',
        provider_url: 'https://open.spotify.com',
        handler(href) {
            if (href === 'https://open.spotify.com')
                return;
            return createIframeNode({
                src: href.replace('https://open.spotify.com/', 'https://open.spotify.com/embed/'),
            });
        },
    },
    {
        provider_name: 'Figma',
        provider_url: 'https://www.figma.com',
        handler(href) {
            if (!href.startsWith('https://www.figma.com/file/'))
                return;
            return createIframeNode({
                sandbox: 'allow-scripts allow-same-origin',
                src: `https://www.figma.com/embed?embed_host=${location.host}&url=${href}`,
            });
        },
    },
];

var providers = [
    {
        provider_name: 'Avocode',
        provider_url: 'https://www.avocode.com/',
        endpoints: [
            {
                schemes: ['https://app.avocode.com/view/*'],
                url: 'https://stage-embed.avocode.com/api/oembed',
            },
        ],
    },
    {
        provider_name: 'Zeplin',
        provider_url: 'https://zeplin.io',
        endpoints: [
            {
                schemes: [
                    'https://app.zeplin.io/project/*/screen/*',
                    'https://app.zeplin.io/project/*/screen/*/version/*',
                    'https://app.zeplin.io/project/*/styleguide/components?coid=*',
                    'https://app.zeplin.io/styleguide/*/components?coid=*',
                ],
                url: 'https://app.zeplin.io/embed',
            },
        ],
    },
    {
        provider_name: 'CodePen',
        provider_url: 'https://codepen.io',
        endpoints: [
            {
                schemes: ['http://codepen.io/*', 'https://codepen.io/*'],
                url: 'https://codepen.io/api/oembed',
            },
        ],
    },
    {
        provider_name: 'CodeSandbox',
        provider_url: 'https://codesandbox.io',
        endpoints: [
            {
                schemes: ['https://codesandbox.io/s/*', 'https://codesandbox.io/embed/*'],
                url: 'https://codesandbox.io/oembed',
            },
        ],
    },
    {
        provider_name: 'Replit',
        provider_url: 'https://repl.it/',
        endpoints: [
            {
                schemes: ['https://repl.it/@*/*', 'https://replit.com/@*/*'],
                url: 'https://repl.it/data/oembed',
                proxy: true,
            },
        ],
    },
    {
        provider_name: 'Runkit',
        provider_url: 'https://runkit.com',
        endpoints: [
            {
                schemes: ['https://runkit.com/*', 'http://embed.runkit.com/*,', 'https://embed.runkit.com/*,'],
                url: 'https://embed.runkit.com/oembed',
                formats: ['json'],
            },
        ],
    },
    {
        provider_name: 'GIPHY',
        provider_url: 'https://giphy.com',
        endpoints: [
            {
                schemes: [
                    'https://giphy.com/gifs/*',
                    'https://giphy.com/clips/*',
                    'http://gph.is/*',
                    'https://media.giphy.com/media/*/giphy.gif',
                ],
                url: 'https://giphy.com/services/oembed',
                discovery: true,
            },
        ],
    },
    {
        provider_name: 'Grain',
        provider_url: 'https://grain.co',
        endpoints: [
            {
                schemes: ['https://grain.co/highlight/*'],
                url: 'http://api.grain.co/_/api/oembed',
                proxy: true,
            },
        ],
    },
    {
        provider_name: 'Vimeo',
        provider_url: 'https://vimeo.com/',
        endpoints: [
            {
                schemes: [
                    'https://vimeo.com/*',
                    'https://vimeo.com/album/*/video/*',
                    'https://vimeo.com/channels/*/*',
                    'https://vimeo.com/groups/*/videos/*',
                    'https://vimeo.com/ondemand/*/*',
                    'https://player.vimeo.com/video/*',
                ],
                url: 'https://vimeo.com/api/oembed.json',
                discovery: true,
            },
        ],
    },
    {
        provider_name: 'YouTube',
        provider_url: 'https://www.youtube.com/',
        endpoints: [
            {
                schemes: [
                    'https://*.youtube.com/watch*',
                    'https://*.youtube.com/v/*',
                    'https://youtu.be/*',
                    'https://*.youtube.com/playlist?list=*',
                ],
                url: 'https://www.youtube.com/oembed',
            },
        ],
    },
    {
        provider_name: 'SoundCloud',
        provider_url: 'http://soundcloud.com/',
        endpoints: [
            {
                schemes: ['http://soundcloud.com/*', 'https://soundcloud.com/*', 'https://soundcloud.app.goog.gl/*'],
                url: 'https://soundcloud.com/oembed',
            },
        ],
    },
    {
        provider_name: 'Spotify',
        provider_url: 'https://spotify.com/',
        endpoints: [
            {
                schemes: ['https://open.spotify.com/*', 'spotify:*'],
                url: 'https://open.spotify.com/oembed/',
            },
        ],
    },
    {
        provider_name: 'SlideShare',
        provider_url: 'http://www.slideshare.net/',
        endpoints: [
            {
                schemes: [
                    'https://www.slideshare.net/*/*',
                    'http://www.slideshare.net/*/*',
                    'https://fr.slideshare.net/*/*',
                    'http://fr.slideshare.net/*/*',
                    'https://de.slideshare.net/*/*',
                    'http://de.slideshare.net/*/*',
                    'https://es.slideshare.net/*/*',
                    'http://es.slideshare.net/*/*',
                    'https://pt.slideshare.net/*/*',
                    'http://pt.slideshare.net/*/*',
                ],
                url: 'https://www.slideshare.net/api/oembed/2',
                proxy: true,
            },
        ],
    },
    {
        provider_name: 'SpeakerDeck',
        provider_url: 'https://speakerdeck.com',
        endpoints: [
            {
                schemes: ['http://speakerdeck.com/*/*', 'https://speakerdeck.com/*/*'],
                url: 'https://speakerdeck.com/oembed.json',
                proxy: true,
            },
        ],
    },
    {
        provider_name: 'Twitter',
        provider_url: 'http://www.twitter.com/',
        endpoints: [
            {
                schemes: [
                    'https://twitter.com/*/status/*',
                    'https://*.twitter.com/*/status/*',
                    'https://twitter.com/*/moments/*',
                    'https://*.twitter.com/*/moments/*',
                ],
                url: 'https://publish.twitter.com/oembed',
                proxy: true,
            },
        ],
    },
];

function handleProxiedOEmbed(target, oembed) {
    if (oembed.type !== 'rich' && oembed.type !== 'video') {
        return;
    }
    switch (oembed.provider_name) {
        case 'Twitter':
            handleTwitter(target, oembed);
            break;
        case 'replit':
        case 'SlideShare':
        case 'Speaker Deck':
        case 'Grain': {
            const doc = new DOMParser().parseFromString(oembed.html, 'text/html');
            const iframe = doc.body.querySelector('iframe');
            if ((iframe === null || iframe === void 0 ? void 0 : iframe.childElementCount) !== 0 ||
                (!iframe.src.startsWith('https://replit.com/@') &&
                    !iframe.src.startsWith('https://www.slideshare.net/slideshow/embed_code') &&
                    !iframe.src.startsWith('https://speakerdeck.com/player/') &&
                    !iframe.src.startsWith('http://speakerdeck.com/player/') &&
                    !iframe.src.startsWith('https://grain.co/_/embed/'))) {
                return;
            }
            for (const attr of [].slice.call(iframe.attributes)) {
                if (attr !== 'src' && attr !== 'sandbox') {
                    iframe.removeAttribute(attr);
                }
            }
            target.replaceWith(iframe);
            break;
        }
    }
}
function handleTwitter(target, oembed) {
    const doc = new DOMParser().parseFromString(oembed.html, 'text/html');
    for (const node of [].slice.call(doc.body.querySelectorAll('body *'))) {
        if (['P', 'BLOCKQUOTE', 'BR'].includes(node.tagName))
            continue;
        switch (node.tagName) {
            case 'SCRIPT':
                if (node.src.startsWith('https://platform.twitter.com/')) {
                    continue;
                }
                break;
            case 'A': {
                const url = new URL(node.href);
                if (['https://t.co', 'https://twitter.com'].includes(url.origin))
                    continue;
                break;
            }
        }
        throw new Error('Unknown content, aborting');
    }
    target.addEventListener('load', () => {
        if (!target.contentDocument) {
            return;
        }
        const style = document.createElement('style');
        style.textContent = `body { margin: 0; }.twitter-tweet { margin: 0 !important; }`;
        target.contentDocument.body.appendChild(style);
        const observer = new MutationObserver(records => {
            let node;
            for (const record of records) {
                if (record.type === 'childList' &&
                    (node = [].find.call(record.addedNodes, node => node.matches('div[class*="twitter-tweet-rendered"]'))) &&
                    node.firstElementChild) {
                    observer.observe(node.firstElementChild, {
                        attributes: true,
                        attributeFilter: ['style'],
                    });
                }
                else if (record.type === 'attributes' &&
                    target.parentElement &&
                    record.target.style.height !== '0px') {
                    target.parentElement.style.height = record.target.style.height;
                    observer.disconnect();
                }
            }
        });
        const node = target.contentDocument.querySelector('div[class*="twitter-tweet-rendered"]');
        observer.observe(node !== null && node !== void 0 ? node : target.contentDocument.body, {
            childList: true,
        });
        if (node === null || node === void 0 ? void 0 : node.firstElementChild) {
            observer.observe(node.firstElementChild, {
                attributes: true,
                attributeFilter: ['style'],
            });
        }
    }, { once: true });
    target.srcdoc = oembed.html;
}

const SYMBOL_NAME = '@stoplight/markdown-viewer/oembed-runtime';
const SYMBOL = Symbol(SYMBOL_NAME);
const spawnRuntime = (window) => {
    const { document } = window;
    const runtime = {
        createPhotoOEmbed(oembed) {
            const img = document.createElement('img');
            Object.assign(img, {
                src: oembed.url,
                width: oembed.width,
                height: oembed.height,
                alt: oembed.title,
            });
            return img;
        },
        createVideoOEmbed(oembed) {
            var _a;
            const doc = new DOMParser().parseFromString(oembed.html, 'text/html');
            let iframe = doc.querySelector('iframe');
            if (iframe === null) {
                iframe = document.createElement('iframe');
                iframe.srcdoc = oembed.html;
            }
            iframe.style.cssText += `width:100%;height:100%`;
            Object.assign(iframe, {
                width: (_a = iframe.width) !== null && _a !== void 0 ? _a : '100%',
                height: iframe.height,
                referrerpolicy: 'no-referrer',
                seamless: true,
                sandbox: 'allow-scripts allow-same-origin',
            });
            return iframe;
        },
        handleProxiedOEmbed,
        processOEmbed(oembed, proxy) {
            if (!window.frameElement) {
                throw ReferenceError('window.frameElement not available');
            }
            if (proxy) {
                return this.handleProxiedOEmbed(window.frameElement, oembed);
            }
            switch (oembed.type) {
                case 'photo':
                    window.frameElement.replaceWith(this.createPhotoOEmbed(oembed));
                    break;
                case 'rich':
                case 'video':
                    window.frameElement.replaceWith(this.createVideoOEmbed(oembed));
                    break;
                case 'link':
                default:
                    throw Error('OEmbed links are not supported');
            }
        },
        async fetchOEmbed(href, proxy) {
            if (proxy) {
                const url = new URL('https://api.allorigins.win/get');
                url.searchParams.set('url', href);
                ({ href } = url);
            }
            const res = await fetch(href, { mode: 'cors' });
            if (!res.ok || res.status < 200 || res.status > 300) {
                throw Error(`Error fetching oembed: ${res.statusText}`);
            }
            const json = await res.json();
            return proxy ? JSON.parse(json.contents) : json;
        },
    };
    for (const [key, fn] of Object.entries(runtime)) {
        runtime[key] = fn.bind(runtime);
    }
    return runtime;
};
const createOEmbedElement = (href, proxy) => {
    if (typeof window !== 'undefined' && !(SYMBOL in window.top)) {
        Reflect.defineProperty(window.top, SYMBOL, {
            value: spawnRuntime,
        });
    }
    return createIframeNode({
        srcdoc: `<script>
  const symbol = Object.getOwnPropertySymbols(window.top).find(symbol => symbol.description === "${SYMBOL_NAME}");
  if (symbol === void 0 || !(symbol in window.top)) {
    throw Error('Runtime chunk not found');
  }

  const { fetchOEmbed, processOEmbed } = window.top[symbol](window);
  fetchOEmbed(${JSON.stringify(href)}, ${JSON.stringify(proxy)}).then(oembed => void processOEmbed(oembed, ${JSON.stringify(proxy)}));
</script>`,
    });
};

const getProviderEndpoint = (linkUrl) => {
    for (const provider of providers) {
        for (const endpoint of provider.endpoints) {
            if (!('schemes' in endpoint))
                continue;
            for (let schema of endpoint.schemes) {
                schema = schema.replace('*', '.*');
                const regExp = new RegExp(schema);
                if (regExp.test(linkUrl)) {
                    return {
                        url: endpoint.url,
                        proxy: 'proxy' in endpoint && endpoint.proxy,
                        query: {
                            format: 'json',
                            url: linkUrl,
                        },
                    };
                }
            }
        }
    }
    return;
};
const processNode = (url) => {
    for (const provider of customProviders) {
        const { origin } = new URL(url.replace('://www', '://'));
        if (provider.provider_url.replace('://www', '://').startsWith(origin)) {
            return provider.handler(url);
        }
    }
    const endpoint = getProviderEndpoint(url);
    if (!endpoint) {
        return;
    }
    const endpointUrl = new URL(endpoint.url);
    for (const [key, value] of Object.entries(endpoint.query)) {
        endpointUrl.searchParams.set(key, value);
    }
    return createOEmbedElement(endpointUrl.href, endpoint.proxy);
};
const embed = function () {
    return function (tree) {
        visit(tree, ((node) => {
            return node.tagName === 'a';
        }), (node, index, parent) => {
            var _a;
            if (parent === null || index === null)
                return;
            const href = (_a = node.properties) === null || _a === void 0 ? void 0 : _a.href;
            if (!isValidUrl(href))
                return;
            const generatedNode = processNode(href);
            if (generatedNode) {
                parent.children[index] = generatedNode;
            }
        });
        return tree;
    };
};
function isValidUrl(url) {
    if (typeof url !== 'string')
        return false;
    try {
        new URL(url);
        return true;
    }
    catch (_a) {
        return false;
    }
}

function sanitize(schema) {
    return function transformer(tree) {
        return sanitize$1(tree, schema);
    };
}

let sanitizationSchema = null;
const buildSanitizationSchema = () => {
    if (!sanitizationSchema) {
        sanitizationSchema = deepmerge(defaultSchema, {
            tagNames: ['tabs', 'tab', 'codegroup', 'button'],
            attributes: {
                '*': ['className', 'style', 'id'],
                code: ['title', 'lineNumbers', 'inline', 'highlightLines', 'lang', 'live', 'jsonSchema', 'http', 'resolved'],
                img: ['bg', 'focus', 'inline', 'invertOnDark'],
                blockquote: ['theme'],
            },
        });
        sanitizationSchema.clobber = ['name'];
    }
    return sanitizationSchema;
};
const mdast2React = (input, opts = {}) => {
    const processorInstance = createMdastToHastProcessor(opts).use(rehypeReact, {
        createElement,
        Fragment,
        components: opts.components,
    });
    return processorInstance.stringify(processorInstance.runSync(input));
};
const createMdastToHastProcessor = (opts = {}) => {
    return (unified()
        .use(remark2rehype, { allowDangerousHtml: true, handlers: { code: codeHandler } })
        .use(rehypeRaw)
        .use(sanitize, buildSanitizationSchema())
        .use(embed)
        .use(opts.rehypePlugins || [])
        .data('settings', opts.settings));
};
const codeHandler = (h, node) => {
    const value = node.value ? node.value + '\n' : '';
    const props = {};
    if (node.resolved) {
        props.resolved = typeof node.resolved === 'string' ? node.resolved : JSON.stringify(node.resolved);
    }
    const code = h(node, 'code', props, [u('text', value)]);
    if (node.meta) {
        code.data = { meta: node.meta };
    }
    return code;
};
const parse = parse$1;
const markdown2React = (input, opts = {}) => {
    const processed = createHastProcessor(opts)
        .use(rehypeReact, { createElement, Fragment, components: opts.components })
        .processSync(input);
    return processed.result;
};
const createHastProcessor = (opts = {}) => {
    return (unified()
        .use(remarkParse)
        .use(remarkParsePreset)
        .use(opts.remarkPlugins || [])
        .use(remark2rehype, { allowDangerousHtml: true, handlers: { code: codeHandler } })
        .use(rehypeRaw)
        .use(sanitize, buildSanitizationSchema())
        .use(embed)
        .use(opts.rehypePlugins || [])
        .data('settings', opts.settings));
};

function computeToc(tree, maxDepth) {
    const headings = selectAll('root > [type=heading]', tree).map((heading) => {
        var _a;
        return ({
            title: findTitle(heading),
            id: String(((_a = heading.data) === null || _a === void 0 ? void 0 : _a.id) || ''),
            depth: heading.depth,
        });
    });
    const root = headings.find(item => item.depth === 1) || { title: 'On this page', id: '', depth: 1 };
    const children = headings.filter(item => item.depth > 1 && item.depth <= maxDepth && item.id);
    return [root, ...children];
}
const findTitle = (parent) => {
    return selectAll('[type=text]', parent).map(textNode => String(textNode.value)).join(' ');
};

const EMPTY_OBJ$2 = {};
const useMdast2React = (mdastRoot, opts = EMPTY_OBJ$2) => {
    return React__default.useMemo(() => {
        const o = {
            components: opts.components,
            rehypePlugins: opts.rehypePlugins,
            remarkPlugins: opts.remarkPlugins,
            settings: opts.settings,
        };
        return mdast2React(mdastRoot, o);
    }, [mdastRoot, opts.components, opts.rehypePlugins, opts.remarkPlugins, opts.settings]);
};

const useToc = (mdastRoot, { enabled, maxDepth }) => {
    return React__default.useMemo(() => {
        if (!enabled)
            return [];
        return computeToc(mdastRoot, maxDepth);
    }, [mdastRoot, enabled, maxDepth]);
};

const MarkdownToc = ({ toc, container, basePath, }) => {
    const { width } = useComponentSize({ current: container });
    const isMinimal = width <= 768;
    if (!toc)
        return null;
    if (isMinimal) {
        return React.createElement(MarkdownTocPopover, { toc: toc, basePath: basePath });
    }
    return React.createElement(MarkdownTocComponent, { toc: toc, container: container, basePath: basePath });
};
const MarkdownTocPopover = React.memo(({ toc, basePath }) => {
    return (React.createElement(Box, { className: "sl-markdown-viewer-toc", pos: "sticky", pl: 4, top: 4, h: "full" },
        React.createElement(Popover, { renderTrigger: React.createElement(Button, { size: "sm", borderColor: "light", icon: ['fas', 'stream'] }), placement: "bottom" },
            React.createElement(Box, { overflowY: "auto", overflowX: "hidden", style: { width: 220 } }, toc.map((heading, i) => (React.createElement(MarkdownTocLink, { key: i, item: heading, basePath: basePath })))))));
});
const MarkdownTocComponent = React.memo(({ toc, container, basePath }) => {
    const currentHighlightId = useScrollSpy(toc, container);
    return (React.createElement(Box, { className: "sl-markdown-viewer-toc", pl: 16, w: 60 },
        React.createElement(Box, { pos: "sticky", top: 0 },
            React.createElement(Box, { pos: "absolute", overflowY: "auto", h: "screen", w: "full" },
                React.createElement(Box, { py: 8 }, toc.map((heading, i) => (React.createElement(MarkdownTocLink, { key: i, item: heading, isSelected: currentHighlightId === heading.id, borderL: 2, basePath: basePath }))))))));
});
const MarkdownTocLink = React.memo(({ item, isSelected, basePath, ...boxProps }) => {
    return (React.createElement(Box, { as: "a", href: `${basePath}#${item.id}`, display: "block", pr: 2, py: 1, pl: item.depth === 1 ? 4 : item.depth * 2, fontWeight: "medium", fontSize: "sm", borderColor: isSelected ? 'primary' : 'light', color: {
            default: isSelected ? 'primary' : 'muted',
            hover: 'primary-dark',
        }, textOverflow: "truncate", title: item.title, ...boxProps }, item.title));
});
const useScrollSpy = (toc, container) => {
    const [currentHeadingId, setHeadingId] = React.useState();
    const currentEntries = React.useRef({});
    const observer = React.useRef();
    React.useEffect(() => {
        if (observer.current) {
            currentEntries.current = {};
            observer.current.disconnect();
        }
        if (!toc.length || !container || typeof window === 'undefined' || !window.IntersectionObserver)
            return;
        const sections = [];
        toc.forEach(item => {
            try {
                const section = container.querySelector(`#${item.id}`);
                if (section) {
                    sections.push(section);
                }
            }
            catch (_) { }
        });
        if (!sections.length)
            return;
        observer.current = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.target.id) {
                    currentEntries.current[entry.target.id] = entry;
                }
            });
            const visibleHeadings = [];
            Object.keys(currentEntries.current).forEach(entryId => {
                const headingElement = currentEntries.current[entryId];
                if (headingElement === null || headingElement === void 0 ? void 0 : headingElement.isIntersecting) {
                    visibleHeadings.push(headingElement);
                }
            });
            visibleHeadings.sort((a, b) => b.time - a.time);
            if (visibleHeadings[0]) {
                setHeadingId(visibleHeadings[0].target.id);
            }
        }, {
            rootMargin: '0px 0px -50%',
            threshold: 1.0,
        });
        const currentObserver = observer.current;
        sections.forEach(element => currentObserver.observe(element));
        return () => {
            currentEntries.current = {};
            sections.forEach(element => currentObserver.unobserve(element));
            currentObserver.disconnect();
        };
    }, [toc, container]);
    return currentHeadingId;
};

const MarkdownViewer = ({ onError, FallbackComponent = MarkdownViewerFallbackComponent, ...props }) => {
    return (React__default.createElement(ErrorBoundary, { onError: onError, FallbackComponent: FallbackComponent },
        React__default.createElement(MarkdownViewerComponent, { ...props })));
};
MarkdownViewer.displayName = 'MarkdownViewer';
const EMPTY_OBJ$1 = {};
const MarkdownViewerComponent = ({ markdown: markdownOrTree, parseOptions = {}, color, className = '', includeToc = false, tocMaxDepth = 3, tocBasePath = '', ...props }) => {
    const contextComponents = useMarkdownViewer().components || EMPTY_OBJ$1;
    const components = (parseOptions === null || parseOptions === void 0 ? void 0 : parseOptions.components) || EMPTY_OBJ$1;
    const componentMapping = React__default.useMemo(() => ({ ...DefaultSMDComponents, ...contextComponents, ...components }), [components, contextComponents]);
    const mdastTree = useMarkdown2Mdast(markdownOrTree, {
        ...parseOptions,
        components: componentMapping,
    });
    const tocTree = useToc(mdastTree, { enabled: includeToc, maxDepth: tocMaxDepth });
    const reactTree = useMdast2React(mdastTree, { ...parseOptions, components: componentMapping });
    const [container, setContainer] = React__default.useState(null);
    if (includeToc && tocTree.length > 1) {
        return (React__default.createElement(Flex, { ref: setContainer, pos: "relative" },
            React__default.createElement(Prose, { className: ['sl-markdown-viewer', className].join(' '), ...props, flex: 1, overflowY: "auto", overflowX: "auto", p: 2 }, reactTree),
            React__default.createElement(MarkdownToc, { toc: tocTree, container: container, basePath: tocBasePath })));
    }
    return (React__default.createElement(Prose, { className: ['sl-markdown-viewer', className].join(' '), ...props }, reactTree));
};
MarkdownViewerComponent.displayName = 'MarkdownViewer.Component';
const MarkdownViewerFallbackComponent = ({ error }) => {
    return (React__default.createElement(Box, { p: 4 },
        React__default.createElement("b", null, "Error"),
        error && `: ${error.message}`));
};

const EMPTY_OBJ = {};
const useMarkdownTree = (markdownOrTree, opts = EMPTY_OBJ) => {
    return React__default.useMemo(() => {
        const o = {
            components: opts.components,
            rehypePlugins: opts.rehypePlugins,
            remarkPlugins: opts.remarkPlugins,
            settings: opts.settings,
        };
        return typeof markdownOrTree === 'string' ? markdown2React(markdownOrTree, o) : mdast2React(markdownOrTree, o);
    }, [markdownOrTree, opts.components, opts.rehypePlugins, opts.remarkPlugins, opts.settings]);
};

export { DEFAULT_MERMAID_SCRIPT_URL, DefaultSMDComponents, MarkdownViewer, MarkdownViewerProvider, buildSanitizationSchema, codeHandler, computeToc, markdown2React, mdast2React, parse, useLoadMermaid, useMarkdownTree, useMarkdownViewer, useRenderMermaid };
