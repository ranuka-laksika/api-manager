{"version":3,"file":"react-overflow-list.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import React from 'react';\nimport {\n  useMount,\n  useMeasure,\n  usePrevious,\n  useShallowCompareEffect,\n  useUpdateEffect,\n} from 'react-use';\n\ntype CollapseDirection = 'start' | 'end';\ntype OverflowDirection = 'none' | 'grow' | 'shrink';\n\nexport interface OverflowListProps<T> {\n  items: T[];\n  itemRenderer: (item: T, index: number) => React.ReactNode;\n  overflowRenderer: (items: T[]) => React.ReactNode;\n  minVisibleItems?: number;\n  onOverflow?: (items: T[]) => void;\n  collapseFrom?: CollapseDirection;\n  className?: string;\n  tagName?: keyof JSX.IntrinsicElements;\n  alwaysRenderOverflow?: boolean;\n}\n\ninterface OverflowListState<T> {\n  visible: T[];\n  overflow: T[];\n  lastOverflowCount: number;\n  overflowDirection: OverflowDirection;\n}\n\nexport function OverflowList<T>(props: OverflowListProps<T>) {\n  const {\n    items,\n    collapseFrom = 'end',\n    minVisibleItems = 0,\n    tagName = 'div',\n    className = '',\n    alwaysRenderOverflow = false,\n    overflowRenderer,\n    itemRenderer,\n  } = props;\n  const [state, setState] = React.useState<OverflowListState<T>>({\n    visible: items,\n    overflow: [],\n    lastOverflowCount: 0,\n    overflowDirection: 'none',\n  });\n\n  const spacer = React.useRef<HTMLDivElement>(null);\n\n  useShallowCompareEffect(() => {\n    repartition(false);\n  }, [state]);\n\n  useMount(() => {\n    repartition(false);\n  });\n\n  useUpdateEffect(() => {\n    setState(() => ({\n      overflowDirection: 'none',\n      lastOverflowCount: 0,\n      overflow: [],\n      visible: items,\n    }));\n  }, [items]);\n\n  const WrapperComponent = tagName;\n\n  const maybeOverflow =\n    state.overflow.length === 0 && !alwaysRenderOverflow\n      ? null\n      : overflowRenderer(state.overflow);\n\n  const repartition = (growing: boolean) => {\n    if (!spacer.current) {\n      return;\n    }\n\n    if (growing) {\n      setState((state) => ({\n        overflowDirection: 'grow',\n        lastOverflowCount:\n          state.overflowDirection === 'none'\n            ? state.overflow.length\n            : state.lastOverflowCount,\n        overflow: [],\n        visible: props.items,\n      }));\n    } else if (spacer.current.getBoundingClientRect().width < 0.9) {\n      setState((state) => {\n        if (state.visible.length <= minVisibleItems!) {\n          return state;\n        }\n        const collapseFromStart = collapseFrom === 'start';\n        const visible = state.visible.slice();\n        const next = collapseFromStart ? visible.shift() : visible.pop();\n        if (!next) {\n          return state;\n        }\n        const overflow = collapseFromStart\n          ? [...state.overflow, next]\n          : [next, ...state.overflow];\n        return {\n          ...state,\n          direction:\n            state.overflowDirection === 'none'\n              ? 'shrink'\n              : state.overflowDirection,\n          overflow,\n          visible,\n        };\n      });\n    } else {\n      setState((prevState) => {\n        return { ...prevState, overflowDirection: 'none' };\n      });\n    }\n  };\n\n  const [ref, { width }] = useMeasure<any>();\n  const previousWidth = usePrevious(width);\n\n  React.useEffect(() => {\n    if (!previousWidth) return;\n\n    repartition(width > previousWidth);\n  }, [width, previousWidth]);\n\n  return (\n    <WrapperComponent\n      // @ts-ignore\n      ref={ref}\n      className={className}\n      style={{\n        display: 'flex',\n        flexWrap: 'nowrap',\n        minWidth: 0,\n      }}\n    >\n      {collapseFrom === 'start' ? maybeOverflow : null}\n      {state.visible.map(itemRenderer)}\n      {collapseFrom === 'end' ? maybeOverflow : null}\n      <div style={{ flexShrink: 1, width: 1 }} ref={spacer} />\n    </WrapperComponent>\n  );\n}\n"],"names":["props","items","collapseFrom","minVisibleItems","tagName","className","alwaysRenderOverflow","overflowRenderer","itemRenderer","React","useState","visible","overflow","lastOverflowCount","overflowDirection","state","setState","spacer","useRef","useShallowCompareEffect","repartition","useMount","useUpdateEffect","WrapperComponent","maybeOverflow","length","growing","current","getBoundingClientRect","width","collapseFromStart","slice","next","shift","pop","direction","prevState","useMeasure","ref","previousWidth","usePrevious","useEffect","style","display","flexWrap","minWidth","map","flexShrink"],"mappings":"oZA+BgCA,OAE5BC,EAQED,EARFC,QAQED,EAPFE,aAAAA,aAAe,UAObF,EANFG,gBAAAA,aAAkB,MAMhBH,EALFI,QAAAA,aAAU,UAKRJ,EAJFK,UAAAA,aAAY,OAIVL,EAHFM,qBAAAA,gBACAC,EAEEP,EAFFO,iBACAC,EACER,EADFQ,eAEwBC,EAAMC,SAA+B,CAC7DC,QAASV,EACTW,SAAU,GACVC,kBAAmB,EACnBC,kBAAmB,SAJdC,OAAOC,OAORC,EAASR,EAAMS,OAAuB,MAE5CC,2BAAwB,WACtBC,GAAY,KACX,CAACL,IAEJM,YAAS,WACPD,GAAY,MAGdE,mBAAgB,WACdN,GAAS,iBAAO,CACdF,kBAAmB,OACnBD,kBAAmB,EACnBD,SAAU,GACVD,QAASV,QAEV,CAACA,QAEEsB,EAAmBnB,EAEnBoB,EACsB,IAA1BT,EAAMH,SAASa,QAAiBnB,EAE5BC,EAAiBQ,EAAMH,UADvB,KAGAQ,EAAc,SAACM,GACdT,EAAOU,UAIRD,EACFV,GAAS,SAACD,SAAW,CACnBD,kBAAmB,OACnBD,kBAC8B,SAA5BE,EAAMD,kBACFC,EAAMH,SAASa,OACfV,EAAMF,kBACZD,SAAU,GACVD,QAASX,EAAMC,UAERgB,EAAOU,QAAQC,wBAAwBC,MAAQ,GACxDb,GAAS,SAACD,MACJA,EAAMJ,QAAQc,QAAUtB,SACnBY,MAEHe,EAAqC,UAAjB5B,EACpBS,EAAUI,EAAMJ,QAAQoB,QACxBC,EAAOF,EAAoBnB,EAAQsB,QAAUtB,EAAQuB,UACtDF,SACIjB,MAEHH,EAAWkB,YACTf,EAAMH,UAAUoB,KACnBA,UAASjB,EAAMH,sBAEfG,GACHoB,UAC8B,SAA5BpB,EAAMD,kBACF,SACAC,EAAMD,kBACZF,SAAAA,EACAD,QAAAA,OAIJK,GAAS,SAACoB,eACIA,GAAWtB,kBAAmB,gBAKvBuB,eAAlBC,OAAOT,OAAAA,MACRU,EAAgBC,cAAYX,UAElCpB,EAAMgC,WAAU,WACTF,GAELnB,EAAYS,EAAQU,KACnB,CAACV,EAAOU,IAGT9B,gBAACc,GAECe,IAAKA,EACLjC,UAAWA,EACXqC,MAAO,CACLC,QAAS,OACTC,SAAU,SACVC,SAAU,IAGM,UAAjB3C,EAA2BsB,EAAgB,KAC3CT,EAAMJ,QAAQmC,IAAItC,GACD,QAAjBN,EAAyBsB,EAAgB,KAC1Cf,uBAAKiC,MAAO,CAAEK,WAAY,EAAGlB,MAAO,GAAKS,IAAKrB"}