'use strict';

var jsonSchemaTree = require('@stoplight/json-schema-tree');
var mosaic = require('@stoplight/mosaic');
var reactErrorBoundary = require('@stoplight/react-error-boundary');
var cn = require('classnames');
var jotai = require('jotai');
var utils = require('jotai/utils');
var React = require('react');
var json = require('@stoplight/json');
var last = require('lodash/last.js');
var fnv = require('fnv-plus');
var markdownViewer = require('@stoplight/markdown-viewer');
var upperFirst = require('lodash/upperFirst.js');
var capitalize = require('lodash/capitalize.js');
var keys = require('lodash/keys.js');
var omit = require('lodash/omit.js');
var pick = require('lodash/pick.js');
var uniq = require('lodash/uniq.js');
var isEmpty = require('lodash/isEmpty.js');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
var fnv__namespace = /*#__PURE__*/_interopNamespaceDefault(fnv);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const JSVOptionsContext = React__namespace.createContext({
    defaultExpandedDepth: 0,
    viewMode: 'standalone',
    hideExamples: false,
});
const useJSVOptionsContext = () => React__namespace.useContext(JSVOptionsContext);
const JSVOptionsContextProvider = JSVOptionsContext.Provider;

function isNonNullable(maybeNullable) {
    return maybeNullable !== void 0 && maybeNullable !== null;
}

const isNonEmptyParentNode = (node) => jsonSchemaTree.isRegularNode(node) && !!node.children && node.children.length > 0;
function isFlattenableNode(node) {
    if (!jsonSchemaTree.isRegularNode(node))
        return false;
    if ((!isArrayNode(node) && !isDictionaryNode(node)) || !isNonNullable(node.children) || node.children.length === 0) {
        return false;
    }
    return (node.children.length === 1 &&
        ((jsonSchemaTree.isRegularNode(node.children[0]) && (!isArrayNode(node) || !isDictionaryNode(node.children[0]))) ||
            (jsonSchemaTree.isReferenceNode(node.children[0]) && node.children[0].error !== null)));
}
function isPrimitiveArray(node) {
    return isFlattenableNode(node) && isArrayNode(node) && jsonSchemaTree.isRegularNode(node.children[0]) && node.children[0].simple;
}
function isPrimitiveDictionary(node) {
    return (isFlattenableNode(node) && isDictionaryNode(node) && jsonSchemaTree.isRegularNode(node.children[0]) && node.children[0].simple);
}
function isComplexArray(node) {
    return isFlattenableNode(node) && isArrayNode(node) && jsonSchemaTree.isRegularNode(node.children[0]) && !node.children[0].simple;
}
function isComplexDictionary(node) {
    return (isFlattenableNode(node) && isDictionaryNode(node) && jsonSchemaTree.isRegularNode(node.children[0]) && !node.children[0].simple);
}
function isDictionaryNode(node) {
    return (jsonSchemaTree.isRegularNode(node) &&
        node.primaryType === jsonSchemaTree.SchemaNodeKind.Object &&
        json.isPlainObject(node.fragment.additionalProperties));
}
function isArrayNode(node) {
    return jsonSchemaTree.isRegularNode(node) && node.primaryType === jsonSchemaTree.SchemaNodeKind.Array;
}
function visibleChildren(node) {
    var _a, _b;
    if (!jsonSchemaTree.isRegularNode(node) || isPrimitiveArray(node) || isPrimitiveDictionary(node)) {
        return [];
    }
    if (isComplexArray(node) || isComplexDictionary(node)) {
        return (_a = node.children[0].children) !== null && _a !== void 0 ? _a : [];
    }
    return (_b = node.children) !== null && _b !== void 0 ? _b : [];
}
function isPropertyRequired(schemaNode) {
    var _a;
    const { parent } = schemaNode;
    if (parent === null || !jsonSchemaTree.isRegularNode(parent) || schemaNode.subpath.length === 0) {
        return false;
    }
    return !!((_a = parent.required) === null || _a === void 0 ? void 0 : _a.includes(schemaNode.subpath[schemaNode.subpath.length - 1]));
}
function isValidViewMode(node, viewMode) {
    const { validations } = node;
    if (!!validations.writeOnly === !!validations.readOnly) {
        return true;
    }
    return !((viewMode === 'read' && !!validations.writeOnly) || (viewMode === 'write' && !!validations.readOnly));
}
function isRenderableNode(node) {
    if (node.parent === null)
        return true;
    if (isDictionaryNode(node.parent)) {
        return node.subpath.length !== 2 || node.subpath[0] !== 'properties';
    }
    if (isArrayNode(node.parent)) {
        return node.subpath[0] !== 'additionalItems';
    }
    if (jsonSchemaTree.isRegularNode(node.parent) && node.parent.primaryType === jsonSchemaTree.SchemaNodeKind.Object && jsonSchemaTree.isBooleanishNode(node)) {
        return !(node.subpath.length === 1 || node.subpath[0] === 'additionalProperties');
    }
    return true;
}
function shouldNodeBeIncluded(node, viewMode = 'standalone') {
    return ((jsonSchemaTree.isReferenceNode(node) || jsonSchemaTree.isRootNode(node) || isRenderableNode(node)) &&
        (!jsonSchemaTree.isRegularNode(node) || isValidViewMode(node, viewMode)));
}

const hoveredNodeAtom = jotai.atom(null);
const isNodeHoveredAtom = utils.atomFamily((node) => jotai.atom(get => node === get(hoveredNodeAtom)));
utils.atomFamily((parent) => jotai.atom(get => {
    const hoveredNode = get(hoveredNodeAtom);
    if (!hoveredNode || hoveredNode === parent)
        return false;
    return hoveredNode.parent === parent;
}));

const showPathCrumbsAtom = jotai.atom(false);
const pathCrumbsAtom = jotai.atom(get => {
    const node = get(hoveredNodeAtom);
    if (!node)
        return [];
    return propertyPathToObjectPath(node);
});
function propertyPathToObjectPath(node) {
    const objectPath = [];
    let currentNode = node;
    while (currentNode && !jsonSchemaTree.isRootNode(currentNode)) {
        if (jsonSchemaTree.isRegularNode(currentNode)) {
            const pathPart = currentNode.subpath[currentNode.subpath.length - 1];
            if (currentNode.primaryType === 'array') {
                const key = `${pathPart || ''}[]`;
                if (objectPath[objectPath.length - 1]) {
                    objectPath[objectPath.length - 1] = key;
                }
                else {
                    objectPath.push(key);
                }
            }
            else if (pathPart &&
                (currentNode.subpath.length !== 2 || !['allOf', 'oneOf', 'anyOf'].includes(currentNode.subpath[0]))) {
                objectPath.push(currentNode.subpath[currentNode.subpath.length - 1]);
            }
        }
        currentNode = currentNode.parent;
    }
    return objectPath.reverse();
}

const PathCrumbs = ({ parentCrumbs = [] }) => {
    const [showPathCrumbs] = jotai.useAtom(showPathCrumbsAtom);
    const [pathCrumbs] = jotai.useAtom(pathCrumbsAtom);
    const { disableCrumbs } = useJSVOptionsContext();
    if (disableCrumbs) {
        return null;
    }
    const parentCrumbElems = [];
    parentCrumbs.forEach((crumb, i) => {
        parentCrumbElems.push(React__namespace.createElement(mosaic.Box, { key: i }, crumb));
    });
    const pathCrumbElems = [];
    pathCrumbs.forEach((crumb, i) => {
        if (pathCrumbs[i + 1]) {
            pathCrumbElems.push(React__namespace.createElement(mosaic.Box, { key: i }, crumb));
        }
        else {
            pathCrumbElems.push(React__namespace.createElement(mosaic.Box, { key: i, color: "body", fontWeight: "semibold" }, crumb));
        }
    });
    if (!showPathCrumbs || (!parentCrumbElems.length && !pathCrumbElems.length)) {
        return null;
    }
    return (React__namespace.createElement(mosaic.HStack, { spacing: 1, divider: React__namespace.createElement(mosaic.Box, null, "/"), h: "md", mt: -8, borderB: true, pos: "sticky", top: 0, fontFamily: "mono", fontSize: "sm", lineHeight: "none", zIndex: 10, bg: "canvas-pure", px: "px", color: "light", alignItems: "center" },
        parentCrumbElems,
        pathCrumbElems.length && React__namespace.createElement(mosaic.HStack, { divider: React__namespace.createElement(mosaic.Box, { fontWeight: "bold" }, ".") }, pathCrumbElems)));
};

({
    [jsonSchemaTree.SchemaCombinerName.AllOf]: 'and',
    [jsonSchemaTree.SchemaCombinerName.AnyOf]: 'and/or',
    [jsonSchemaTree.SchemaCombinerName.OneOf]: 'or',
});
const COMMON_JSON_SCHEMA_AND_OAS_FORMATS = {
    number: ['byte', 'int32', 'int64', 'float', 'double'],
    get integer() {
        return this.number;
    },
};
const NESTING_OFFSET = 3;
const CARET_ICON_SIZE = 'sm';
const COMBINER_NAME_MAP = {
    allOf: 'all of',
    anyOf: 'any of',
    oneOf: 'one of',
};

let SKIP_HASHING = false;
const hash = (value, skipHashing = SKIP_HASHING) => {
    return skipHashing ? value : fnv__namespace.fast1a52hex(value);
};
const getNodeId = (node, parentId) => {
    const fragment = node.fragment;
    if (json.isPlainObject(fragment) && json.isPlainObject(fragment['x-stoplight'])) {
        const nodeId = fragment['x-stoplight'].id;
        if (typeof nodeId === 'string')
            return nodeId;
    }
    const key = node.path[node.path.length - 1];
    return hash(['schema_property', parentId, String(key)].join('-'));
};
const getOriginalNodeId = (node, parentId) => {
    var _a, _b;
    const nodeId = (_b = (_a = node.originalFragment) === null || _a === void 0 ? void 0 : _a['x-stoplight']) === null || _b === void 0 ? void 0 : _b.id;
    if (nodeId)
        return nodeId;
    const key = node.path[node.path.length - 1];
    return hash(['schema_property', parentId, String(key)].join('-'));
};

function extractVendorExtensions(fragment) {
    if (typeof fragment === 'boolean') {
        return [0, {}];
    }
    const extensionKeys = Object.entries(fragment).filter(([key]) => key.startsWith('x-'));
    let vendorExtensions = {};
    for (const [key, value] of extensionKeys) {
        vendorExtensions[key] = value;
    }
    return [extensionKeys.length, vendorExtensions];
}

const Caret = ({ isExpanded }) => (React__namespace.createElement(mosaic.Flex, { pl: 3, w: 8, ml: -8, color: "muted", role: "button", justifyContent: "center" },
    React__namespace.createElement(mosaic.Icon, { size: CARET_ICON_SIZE, fixedWidth: true, icon: isExpanded ? 'chevron-down' : 'chevron-right' })));

const Description = ({ value }) => {
    const [showAll, setShowAll] = React__namespace.useState(false);
    if (typeof value !== 'string' || value.trim().length === 0)
        return null;
    const paragraphs = value.split('\n\n');
    if (paragraphs.length <= 1 || showAll) {
        return (React__namespace.createElement(mosaic.Box, { as: markdownViewer.MarkdownViewer, "data-test": "property-description", markdown: value, style: {
                fontSize: 12,
            } }));
    }
    const firstParagraph = paragraphs[0];
    return (React__namespace.createElement(mosaic.Box, { as: markdownViewer.MarkdownViewer, "data-test": "property-description", markdown: firstParagraph, parseOptions: {
            components: {
                p: (props) => {
                    return (React__namespace.createElement(mosaic.Box, { as: "p" },
                        React__namespace.createElement(mosaic.Text, { mr: 1 }, props.children),
                        React__namespace.createElement(mosaic.Link, { cursor: "pointer", onClick: () => setShowAll(true) }, "Show all...")));
                },
            },
        }, style: {
            fontSize: 12,
        } }));
};

function getApplicableFormats(schemaNode) {
    if (json.isPlainObject(schemaNode.fragment) &&
        schemaNode.fragment['contentMediaType'] === 'application/octet-stream' &&
        schemaNode.types &&
        schemaNode.types.length > 0) {
        return [schemaNode.types[0], 'binary'];
    }
    if (schemaNode.format === null) {
        return null;
    }
    if (schemaNode.types !== null) {
        for (const type of schemaNode.types) {
            if (!(type in COMMON_JSON_SCHEMA_AND_OAS_FORMATS))
                continue;
            if (COMMON_JSON_SCHEMA_AND_OAS_FORMATS[type].includes(schemaNode.format)) {
                return [type, schemaNode.format];
            }
        }
    }
    return [jsonSchemaTree.SchemaNodeKind.String, schemaNode.format];
}

function printName(schemaNode, { shouldUseRefNameFallback = false } = {}) {
    var _a;
    if (!isFlattenableNode(schemaNode)) {
        return (_a = schemaNode.title) !== null && _a !== void 0 ? _a : (shouldUseRefNameFallback ? getNodeNameFromOriginalRef(schemaNode) : undefined);
    }
    return printFlattenedName(schemaNode, { shouldUseRefNameFallback });
}
function printFlattenedName(schemaNode, { shouldUseRefNameFallback = false }) {
    var _a, _b, _c, _d, _e;
    if (!isNonNullable(schemaNode.children) || schemaNode.children.length === 0) {
        return (_a = schemaNode.title) !== null && _a !== void 0 ? _a : (shouldUseRefNameFallback ? getNodeNameFromOriginalRef(schemaNode) : undefined);
    }
    if (schemaNode.children.length === 1 && jsonSchemaTree.isReferenceNode(schemaNode.children[0])) {
        const value = `$ref(${schemaNode.children[0].value})`;
        return isDictionaryNode(schemaNode) ? `dictionary[string, ${value}]` : `${value}[]`;
    }
    const format = isDictionaryNode(schemaNode) ? 'dictionary[string, %s]' : 'array[%s]';
    if (isPrimitiveArray(schemaNode) || isPrimitiveDictionary(schemaNode)) {
        const val = (_c = (_b = schemaNode.children) === null || _b === void 0 ? void 0 : _b.reduce((mergedTypes, child) => {
            if (mergedTypes === null)
                return null;
            if (!jsonSchemaTree.isRegularNode(child))
                return null;
            if (child.types !== null && child.types.length > 0) {
                const formats = getApplicableFormats(child);
                for (const type of child.types) {
                    if (mergedTypes.includes(type))
                        continue;
                    if (formats !== null && formats[0] === type) {
                        mergedTypes.push(`${type}<${formats[1]}>`);
                    }
                    else {
                        mergedTypes.push(type);
                    }
                }
            }
            return mergedTypes;
        }, [])) !== null && _c !== void 0 ? _c : null;
        if (val !== null && val.length > 0) {
            return format.replace('%s', val.join(' or '));
        }
        return isDictionaryNode(schemaNode) ? 'dictionary[string, any]' : 'array';
    }
    if (isComplexArray(schemaNode) || isComplexDictionary(schemaNode)) {
        const firstChild = schemaNode.children[0];
        if (firstChild.title) {
            return format.replace('%s', firstChild.title);
        }
        else if (shouldUseRefNameFallback && getNodeNameFromOriginalRef(schemaNode)) {
            return format.replace('%s', (_d = getNodeNameFromOriginalRef(schemaNode)) !== null && _d !== void 0 ? _d : 'any');
        }
        else if (firstChild.primaryType) {
            return format.replace('%s', firstChild.primaryType);
        }
        else if ((_e = firstChild.combiners) === null || _e === void 0 ? void 0 : _e.length) {
            return format.replace('%s', firstChild.combiners.join(' '));
        }
        return isComplexArray(schemaNode) ? 'array' : format.replace('%s', 'any');
    }
    return undefined;
}
function getNodeNameFromOriginalRef(node) {
    if (typeof node.originalFragment.$ref === 'string') {
        return upperFirst(json.getLastPathSegment(node.originalFragment.$ref));
    }
    return undefined;
}

function shouldRenderName(type) {
    return type === jsonSchemaTree.SchemaNodeKind.Array || type === jsonSchemaTree.SchemaNodeKind.Object || type === '$ref';
}
function getTypes(schemaNode) {
    return [schemaNode.types, schemaNode.combiners].reduce((values, value) => {
        if (value === null) {
            return values;
        }
        values.push(...value);
        return values;
    }, []);
}
const Types = ({ schemaNode }) => {
    var _a;
    if (jsonSchemaTree.isReferenceNode(schemaNode)) {
        return (React__namespace.createElement(mosaic.Box, { as: "span", textOverflow: "truncate", "data-test": "property-type-ref" }, (_a = schemaNode.value) !== null && _a !== void 0 ? _a : '$ref'));
    }
    if (jsonSchemaTree.isBooleanishNode(schemaNode)) {
        return (React__namespace.createElement(mosaic.Box, { as: "span", textOverflow: "truncate", color: "muted", "data-test": "property-type" }, schemaNode.fragment ? 'any' : 'never'));
    }
    if (!jsonSchemaTree.isRegularNode(schemaNode)) {
        return null;
    }
    const formats = getApplicableFormats(schemaNode);
    const types = getTypes(schemaNode);
    if (types.length === 0) {
        return (React__namespace.createElement(mosaic.Box, { as: "span", textOverflow: "truncate", color: "muted", "data-test": "property-type" }, formats === null ? 'any' : `<${formats[1]}>`));
    }
    const rendered = types.map((type, i, { length }) => {
        let printedName;
        if (shouldRenderName(type)) {
            printedName = printName(schemaNode);
        }
        printedName !== null && printedName !== void 0 ? printedName : (printedName = type + (formats === null || formats[0] !== type ? '' : `<${formats[1]}>`));
        return (React__namespace.createElement(React__namespace.Fragment, { key: type },
            React__namespace.createElement(mosaic.Box, { as: "span", textOverflow: "truncate", color: "muted", "data-test": "property-type" }, printedName),
            i < length - 1 && (React__namespace.createElement(mosaic.Box, { as: "span", key: `${i}-sep`, color: "muted" }, ' or '))));
    });
    return rendered.length > 1 ? React__namespace.createElement(mosaic.Box, { textOverflow: "truncate" }, rendered) : React__namespace.createElement(React__namespace.Fragment, null, rendered);
};
Types.displayName = 'JsonSchemaViewer.Types';

const numberValidationNames = [
    'minimum',
    'maximum',
    'minLength',
    'maxLength',
    'minItems',
    'maxItems',
    'exclusiveMinimum',
    'exclusiveMaximum',
];
const exampleValidationNames = ['examples'];
const excludedValidations = ['exclusiveMinimum', 'exclusiveMaximum', 'readOnly', 'writeOnly'];
const numberValidationFormatters = {
    minimum: value => `>= ${value}`,
    exclusiveMinimum: value => `> ${value}`,
    minItems: value => `>= ${value} items`,
    minLength: value => `>= ${value} characters`,
    maximum: value => `<= ${value}`,
    exclusiveMaximum: value => `< ${value}`,
    maxItems: value => `<= ${value} items`,
    maxLength: value => `<= ${value} characters`,
};
const createStringFormatter = (nowrap) => (value) => {
    return nowrap && typeof value === 'string' ? value : JSON.stringify(value);
};
const createValidationsFormatter = (name, options) => (value) => {
    const values = Array.isArray(value) ? value : [value];
    if (values.length) {
        return {
            name: (options === null || options === void 0 ? void 0 : options.exact) ? name : values.length > 1 ? `${name}s` : `${name}`,
            values: values.map(createStringFormatter(options === null || options === void 0 ? void 0 : options.nowrap)),
        };
    }
    return null;
};
const validationFormatters = {
    enum: createValidationsFormatter('Allowed value', { nowrap: true }),
    examples: createValidationsFormatter('Example', { nowrap: true }),
    multipleOf: createValidationsFormatter('Multiple of', { exact: true }),
    pattern: createValidationsFormatter('Match pattern', { exact: true, nowrap: true }),
    default: createValidationsFormatter('Default', { exact: true, nowrap: true }),
    style: createValidationsFormatter('Style', { exact: true, nowrap: true }),
};
const oasFormats = {
    int32: {
        minimum: 0 - 2 ** 31,
        maximum: 2 ** 31 - 1,
    },
    int64: {
        minimum: Number.MIN_SAFE_INTEGER,
        maximum: Number.MAX_SAFE_INTEGER,
    },
    float: {
        minimum: 0 - 2 ** 128,
        maximum: 2 ** 128 - 1,
    },
    double: {
        minimum: 0 - Number.MAX_VALUE,
        maximum: Number.MAX_VALUE,
    },
    byte: {
        pattern: '^[\\w\\d+\\/=]*$',
    },
};
function isOasFormat(format) {
    return format in oasFormats;
}
function filterOutOasFormatValidations(format, values) {
    if (!isOasFormat(format)) {
        return values;
    }
    const newValues = Object.assign({}, values);
    for (const [key, value] of Object.entries(oasFormats[format])) {
        if (value === newValues[key]) {
            delete newValues[key];
        }
    }
    return newValues;
}
const Validations = ({ validations, hideExamples }) => {
    const numberValidations = pick(validations, numberValidationNames);
    const keyValueValidations = omit(validations, [
        ...keys(numberValidations),
        ...excludedValidations,
        ...(hideExamples ? exampleValidationNames : []),
    ]);
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement(NumberValidations, { validations: numberValidations }),
        React__namespace.createElement(KeyValueValidations, { validations: keyValueValidations })));
};
const NumberValidations = ({ validations, }) => {
    const entries = Object.entries(validations);
    if (!entries.length) {
        return null;
    }
    return (React__namespace.createElement(mosaic.HStack, { color: "muted", maxW: "full", spacing: 1, "data-test": "property-validation" }, entries
        .map(([key, value]) => numberValidationFormatters[key](value))
        .map((value, i) => (React__namespace.createElement(Value, { key: i, name: value })))));
};
const KeyValueValidations = ({ validations }) => (React__namespace.createElement(React__namespace.Fragment, null, keys(validations)
    .filter(key => Object.keys(validationFormatters).includes(key) && validations[key] !== void 0)
    .map(key => {
    const validation = validationFormatters[key](validations[key]);
    if (validation) {
        return React__namespace.createElement(KeyValueValidation, { key: key, name: validation.name, values: validation.values });
    }
    else {
        return null;
    }
})));
const KeyValueValidation = ({ name, values }) => {
    return (React__namespace.createElement(mosaic.HStack, { color: "muted", spacing: 2, alignItems: "baseline", "data-test": "property-validation" },
        React__namespace.createElement(mosaic.Text, null,
            capitalize(name),
            ":"),
        React__namespace.createElement(mosaic.Flex, { flexWrap: true, flex: 1, style: { gap: 4 } }, uniq(values).map(value => (React__namespace.createElement(Value, { key: value, name: value }))))));
};
const Value = ({ name }) => (React__namespace.createElement(mosaic.Text, { px: 1, bg: "canvas-tint", color: "muted", border: true, rounded: true, wordBreak: "all", maxW: "full" }, name));
const getArrayValidations = (schemaNode) => {
    var _a;
    if (((_a = schemaNode.children) === null || _a === void 0 ? void 0 : _a.length) === 1 && jsonSchemaTree.isRegularNode(schemaNode.children[0])) {
        if (schemaNode.children[0].enum !== null) {
            return { enum: schemaNode.children[0].enum };
        }
        else if (schemaNode.children[0].fragment.pattern !== void 0) {
            return { pattern: schemaNode.children[0].fragment.pattern };
        }
    }
    return null;
};
function getValidationsFromSchema(schemaNode) {
    return Object.assign(Object.assign(Object.assign({}, (schemaNode.enum !== null
        ? { enum: schemaNode.enum }
        : schemaNode.primaryType === 'array'
            ?
                getArrayValidations(schemaNode)
            : null)), ('annotations' in schemaNode
        ? Object.assign(Object.assign({}, (schemaNode.annotations.default !== void 0 ? { default: schemaNode.annotations.default } : null)), (schemaNode.annotations.examples ? { examples: schemaNode.annotations.examples } : null)) : null)), getFilteredValidations(schemaNode));
}
function getFilteredValidations(schemaNode) {
    if (schemaNode.format !== null) {
        return filterOutOasFormatValidations(schemaNode.format, schemaNode.validations);
    }
    return schemaNode.validations;
}

const ChildStack = React__namespace.memo(({ childNodes, currentNestingLevel, className, RowComponent = SchemaRow, parentNodeId, parentChangeType, }) => {
    const { renderRootTreeLines } = useJSVOptionsContext();
    const rootLevel = renderRootTreeLines ? 0 : 1;
    const isRootLevel = currentNestingLevel < rootLevel;
    let ml;
    if (!isRootLevel) {
        ml = currentNestingLevel === rootLevel ? 'px' : 7;
    }
    return (React__namespace.createElement(mosaic.Box, { className: className, ml: ml, fontSize: "sm", borderL: isRootLevel ? undefined : true, "data-level": currentNestingLevel }, childNodes.map((childNode) => (React__namespace.createElement(RowComponent, { key: childNode.id, schemaNode: childNode, nestingLevel: currentNestingLevel + 1, pl: isRootLevel ? undefined : NESTING_OFFSET, parentNodeId: parentNodeId, parentChangeType: parentChangeType })))));
});

function getInternalSchemaError(schemaNode) {
    let errorMessage;
    const fragment = schemaNode.fragment;
    if (!json.isPlainObject(fragment))
        return;
    const xStoplight = fragment['x-stoplight'];
    if (json.isPlainObject(xStoplight) && typeof xStoplight['error-message'] === 'string') {
        errorMessage = xStoplight['error-message'];
    }
    else {
        const fragmentErrorMessage = fragment['x-sl-error-message'];
        if (typeof fragmentErrorMessage === 'string') {
            errorMessage = fragmentErrorMessage;
        }
        else {
            const items = fragment['items'];
            if (json.isPlainObject(items)) {
                const itemsErrorMessage = items['x-sl-error-message'];
                if (typeof itemsErrorMessage === 'string') {
                    errorMessage = itemsErrorMessage;
                }
            }
        }
    }
    return errorMessage;
}

function useRefNode(schemaNode) {
    return React__namespace.useMemo(() => {
        var _a, _b, _c;
        if (jsonSchemaTree.isReferenceNode(schemaNode)) {
            return schemaNode;
        }
        if (jsonSchemaTree.isRegularNode(schemaNode) &&
            (isFlattenableNode(schemaNode) ||
                (schemaNode.primaryType === jsonSchemaTree.SchemaNodeKind.Array && ((_a = schemaNode.children) === null || _a === void 0 ? void 0 : _a.length) === 1))) {
            return (_c = (_b = schemaNode.children) === null || _b === void 0 ? void 0 : _b.find(jsonSchemaTree.isReferenceNode)) !== null && _c !== void 0 ? _c : null;
        }
        return null;
    }, [schemaNode]);
}
const Error$1 = ({ schemaNode }) => {
    var _a;
    const refNode = useRefNode(schemaNode);
    const error = (_a = getInternalSchemaError(schemaNode)) !== null && _a !== void 0 ? _a : refNode === null || refNode === void 0 ? void 0 : refNode.error;
    if (typeof error !== 'string')
        return null;
    return (React__namespace.createElement(mosaic.Tooltip, { renderTrigger: React__namespace.createElement(mosaic.Box, { as: "span", display: "inline-block", ml: 1.5 },
            React__namespace.createElement(mosaic.Icon, { "aria-label": error, color: "var(--color-danger)", icon: ['fas', 'exclamation-triangle'], size: "1x" })) }, error));
};

const useHasProperties = ({ required, deprecated, validations: { readOnly, writeOnly } }) => {
    const { viewMode } = useJSVOptionsContext();
    const showVisibilityValidations = viewMode === 'standalone' && !!readOnly !== !!writeOnly;
    return deprecated || showVisibilityValidations || required;
};
const Properties = ({ required, deprecated, validations: { readOnly, writeOnly }, }) => {
    const { viewMode } = useJSVOptionsContext();
    const showVisibilityValidations = viewMode === 'standalone' && !!readOnly !== !!writeOnly;
    const visibility = showVisibilityValidations ? (readOnly ? (React__namespace.createElement(mosaic.Box, { as: "span", ml: 2, color: "muted", "data-test": "property-read-only" }, "read-only")) : (React__namespace.createElement(mosaic.Box, { as: "span", ml: 2, color: "muted", "data-test": "property-write-only" }, "write-only"))) : null;
    return (React__namespace.createElement(React__namespace.Fragment, null,
        deprecated ? (React__namespace.createElement(mosaic.Box, { as: "span", ml: 2, color: "warning", "data-test": "property-deprecated" }, "deprecated")) : null,
        visibility,
        required && (React__namespace.createElement(mosaic.Box, { as: "span", ml: 2, color: "warning", "data-test": "property-required" }, "required"))));
};

function calculateChoiceTitle(node, isPlural) {
    const primitiveSuffix = isPlural ? 's' : '';
    if (jsonSchemaTree.isRegularNode(node)) {
        const realName = printName(node, { shouldUseRefNameFallback: true });
        if (realName) {
            return realName;
        }
        return node.primaryType !== null
            ? node.primaryType + primitiveSuffix
            : String(node.originalFragment.title || 'any');
    }
    if (jsonSchemaTree.isReferenceNode(node)) {
        if (node.value) {
            const value = json.extractPointerFromRef(node.value);
            const lastPiece = !node.error && value ? last(json.pointerToPath(value)) : null;
            if (typeof lastPiece === 'string') {
                return lastPiece.split('.')[0];
            }
        }
        return '$ref' + primitiveSuffix;
    }
    return 'any';
}
function makeChoice(node) {
    return {
        type: node,
        title: calculateChoiceTitle(node, false),
    };
}
function makeArrayChoice(node, combiner) {
    const itemTitle = calculateChoiceTitle(node, true);
    const title = itemTitle !== 'any' ? `array ${combiner ? `(${combiner})` : null} [${itemTitle}]` : 'array';
    return {
        type: node,
        title,
    };
}
const useChoices = (schemaNode) => {
    const choices = React__namespace.useMemo(() => {
        if (isComplexArray(schemaNode) &&
            isNonEmptyParentNode(schemaNode.children[0]) &&
            shouldShowChildSelector(schemaNode.children[0])) {
            return schemaNode.children[0].children.map(child => { var _a; return makeArrayChoice(child, (_a = schemaNode.children[0].combiners) === null || _a === void 0 ? void 0 : _a[0]); });
        }
        if (isNonEmptyParentNode(schemaNode) && shouldShowChildSelector(schemaNode)) {
            return schemaNode.children.map(makeChoice);
        }
        return [makeChoice(schemaNode)];
    }, [schemaNode]);
    const defaultChoice = choices[0];
    const [selectedChoice, setSelectedChoice] = React__namespace.useState(defaultChoice);
    React__namespace.useEffect(() => {
        setSelectedChoice(defaultChoice);
    }, [defaultChoice]);
    const actualSelectedChoice = selectedChoice && choices.includes(selectedChoice) ? selectedChoice : defaultChoice;
    return { selectedChoice: actualSelectedChoice, setSelectedChoice, choices };
};
const shouldShowChildSelector = (schemaNode) => { var _a, _b; return isNonEmptyParentNode(schemaNode) && ['anyOf', 'oneOf'].includes((_b = (_a = schemaNode.combiners) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : ''); };

const SchemaRow = React__namespace.memo(({ schemaNode, nestingLevel, pl, parentNodeId, parentChangeType }) => {
    var _a, _b;
    const { defaultExpandedDepth, renderRowAddon, renderExtensionAddon, onGoToRef, hideExamples, renderRootTreeLines, nodeHasChanged, viewMode, } = useJSVOptionsContext();
    const setHoveredNode = utils.useUpdateAtom(hoveredNodeAtom);
    const nodeId = getNodeId(schemaNode, parentNodeId);
    const originalNodeId = ((_a = schemaNode.originalFragment) === null || _a === void 0 ? void 0 : _a.$ref) ? getOriginalNodeId(schemaNode, parentNodeId) : nodeId;
    const mode = viewMode === 'standalone' ? undefined : viewMode;
    const hasChanged = nodeHasChanged === null || nodeHasChanged === void 0 ? void 0 : nodeHasChanged({ nodeId: originalNodeId, mode });
    const [isExpanded, setExpanded] = React__namespace.useState(!jsonSchemaTree.isMirroredNode(schemaNode) && nestingLevel <= defaultExpandedDepth);
    const { selectedChoice, setSelectedChoice, choices } = useChoices(schemaNode);
    const typeToShow = selectedChoice.type;
    const description = jsonSchemaTree.isRegularNode(typeToShow) ? typeToShow.annotations.description : null;
    const rootLevel = renderRootTreeLines ? 1 : 2;
    const childNodes = React__namespace.useMemo(() => visibleChildren(typeToShow), [typeToShow]);
    const combiner = jsonSchemaTree.isRegularNode(schemaNode) && ((_b = schemaNode.combiners) === null || _b === void 0 ? void 0 : _b.length) ? schemaNode.combiners[0] : null;
    const isCollapsible = childNodes.length > 0;
    const isRootLevel = nestingLevel < rootLevel;
    const required = isPropertyRequired(schemaNode);
    const deprecated = jsonSchemaTree.isRegularNode(schemaNode) && schemaNode.deprecated;
    const validations = jsonSchemaTree.isRegularNode(schemaNode) ? schemaNode.validations : {};
    const hasProperties = useHasProperties({ required, deprecated, validations });
    const [totalVendorExtensions, vendorExtensions] = React__namespace.useMemo(() => extractVendorExtensions(schemaNode.fragment), [schemaNode.fragment]);
    const hasVendorProperties = totalVendorExtensions > 0;
    const annotationRootOffset = renderRootTreeLines ? 0 : 8;
    let annotationLeftOffset = -20 - annotationRootOffset;
    if (nestingLevel > 1) {
        annotationLeftOffset =
            -1 * 29 * Math.max(nestingLevel - 1, 1) - Math.min(nestingLevel, 2) * 2 - 16 - annotationRootOffset;
        if (!renderRootTreeLines) {
            annotationLeftOffset += 27;
        }
    }
    if (parentChangeType === 'added' && hasChanged && hasChanged.type === 'removed') {
        return null;
    }
    if (parentChangeType === 'removed' && hasChanged && hasChanged.type === 'added') {
        return null;
    }
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement(mosaic.Flex, { maxW: "full", pl: pl, py: 2, "data-id": originalNodeId, "data-test": "schema-row", pos: "relative", onMouseEnter: (e) => {
                e.stopPropagation();
                setHoveredNode(selectedChoice.type);
            } },
            !isRootLevel && React__namespace.createElement(mosaic.Box, { borderT: true, w: isCollapsible ? 1 : 3, ml: -3, mr: 3, mt: 2 }),
            parentChangeType !== 'added' && parentChangeType !== 'removed' ? (React__namespace.createElement(mosaic.NodeAnnotation, { change: hasChanged, style: { left: annotationLeftOffset } })) : null,
            React__namespace.createElement(mosaic.VStack, { spacing: 1, maxW: "full", flex: 1, ml: isCollapsible && !isRootLevel ? 2 : undefined },
                React__namespace.createElement(mosaic.Flex, { alignItems: "center", maxW: "full", onClick: isCollapsible ? () => setExpanded(!isExpanded) : undefined, cursor: isCollapsible ? 'pointer' : undefined },
                    isCollapsible ? React__namespace.createElement(Caret, { isExpanded: isExpanded }) : null,
                    React__namespace.createElement(mosaic.Flex, { alignItems: "baseline", fontSize: "base" },
                        schemaNode.subpath.length > 0 && shouldShowPropertyName(schemaNode) && (React__namespace.createElement(mosaic.Box, { mr: 2, fontFamily: "mono", fontWeight: "semibold", "data-test": `property-name-${last(schemaNode.subpath)}` }, last(schemaNode.subpath))),
                        choices.length === 1 && React__namespace.createElement(Types, { schemaNode: typeToShow }),
                        onGoToRef && jsonSchemaTree.isReferenceNode(schemaNode) && schemaNode.external ? (React__namespace.createElement(mosaic.Box, { as: "a", ml: 2, cursor: "pointer", color: "primary-light", onClick: (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                onGoToRef(schemaNode);
                            } }, "(go to ref)")) : null,
                        schemaNode.subpath.length > 1 && schemaNode.subpath[0] === 'patternProperties' ? (React__namespace.createElement(mosaic.Box, { ml: 2, color: "muted" }, "(pattern property)")) : null,
                        choices.length > 1 && (React__namespace.createElement(mosaic.Select, { "aria-label": "Pick a type", size: "sm", triggerTextPrefix: combiner ? `${COMBINER_NAME_MAP[combiner]}: ` : undefined, options: choices.map((choice, index) => ({
                                value: String(index),
                                label: choice.title,
                            })), value: String(choices.indexOf(selectedChoice)), onChange: selectedIndex => setSelectedChoice(choices[selectedIndex]) }))),
                    hasProperties && React__namespace.createElement(Divider, { atom: isNodeHoveredAtom(schemaNode) }),
                    React__namespace.createElement(Properties, { required: required, deprecated: deprecated, validations: validations })),
                typeof description === 'string' && description.length > 0 && React__namespace.createElement(Description, { value: description }),
                React__namespace.createElement(Validations, { validations: jsonSchemaTree.isRegularNode(schemaNode) ? getValidationsFromSchema(schemaNode) : {}, hideExamples: hideExamples }),
                hasVendorProperties && renderExtensionAddon ? (React__namespace.createElement(mosaic.Box, null, renderExtensionAddon({ schemaNode, nestingLevel, vendorExtensions }))) : null),
            React__namespace.createElement(Error$1, { schemaNode: schemaNode }),
            renderRowAddon ? React__namespace.createElement(mosaic.Box, null, renderRowAddon({ schemaNode, nestingLevel })) : null),
        isCollapsible && isExpanded ? (React__namespace.createElement(ChildStack, { schemaNode: schemaNode, childNodes: childNodes, currentNestingLevel: nestingLevel, parentNodeId: nodeId, parentChangeType: parentChangeType ? parentChangeType : hasChanged ? hasChanged === null || hasChanged === void 0 ? void 0 : hasChanged.type : undefined })) : null));
});
const Divider = ({ atom }) => {
    const isHovering = utils.useAtomValue(atom);
    return React__namespace.createElement(mosaic.Box, { bg: isHovering ? 'canvas-200' : undefined, h: "px", flex: 1, mx: 3 });
};
function shouldShowPropertyName(schemaNode) {
    return (schemaNode.subpath.length === 2 &&
        (schemaNode.subpath[0] === 'properties' || schemaNode.subpath[0] === 'patternProperties'));
}

const useIsOnScreen = (ref) => {
    const [isOnScreen, setIsOnScreen] = React.useState(true);
    React.useEffect(() => {
        let observer;
        if (ref.current) {
            const scrollParent = getScrollParent(ref.current);
            observer = new IntersectionObserver(([entry]) => {
                setIsOnScreen(entry.isIntersecting);
            }, {
                root: scrollParent === window ? undefined : scrollParent,
                rootMargin: '20px 0px 0px 0px',
            });
            observer.observe(ref.current);
        }
        return () => {
            observer === null || observer === void 0 ? void 0 : observer.disconnect();
        };
    }, [ref]);
    return isOnScreen;
};
function getScrollParent(node) {
    if (node == null) {
        return null;
    }
    if (node.scrollHeight > node.clientHeight && node.clientHeight > 0) {
        return node.tagName === 'HTML' ? window : node;
    }
    else {
        return getScrollParent(node.parentElement);
    }
}

const TopLevelSchemaRow = ({ schemaNode, skipDescription, }) => {
    var _a;
    const { renderExtensionAddon } = useJSVOptionsContext();
    const { selectedChoice, setSelectedChoice, choices } = useChoices(schemaNode);
    const childNodes = React__namespace.useMemo(() => visibleChildren(selectedChoice.type), [selectedChoice.type]);
    const nestingLevel = 0;
    const nodeId = (() => {
        if (json.isPlainObject(schemaNode.fragment) && json.isPlainObject(schemaNode.fragment['x-stoplight'])) {
            const id = schemaNode.fragment['x-stoplight'].id;
            return typeof id === 'string' ? id : undefined;
        }
        return undefined;
    })();
    const [totalVendorExtensions, vendorExtensions] = React__namespace.useMemo(() => extractVendorExtensions(schemaNode.fragment), [schemaNode.fragment]);
    const hasVendorProperties = totalVendorExtensions > 0;
    if (jsonSchemaTree.isRegularNode(schemaNode) && isPureObjectNode(schemaNode)) {
        return (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(ScrollCheck, null),
            !skipDescription ? React__namespace.createElement(Description, { value: schemaNode.annotations.description }) : null,
            hasVendorProperties && renderExtensionAddon
                ? renderExtensionAddon({ schemaNode, nestingLevel, vendorExtensions })
                : null,
            React__namespace.createElement(ChildStack, { schemaNode: schemaNode, childNodes: childNodes, currentNestingLevel: nestingLevel, parentNodeId: nodeId }),
            React__namespace.createElement(Error$1, { schemaNode: schemaNode })));
    }
    if (jsonSchemaTree.isRegularNode(schemaNode) && choices.length > 1) {
        const combiner = jsonSchemaTree.isRegularNode(schemaNode) && ((_a = schemaNode.combiners) === null || _a === void 0 ? void 0 : _a.length) ? schemaNode.combiners[0] : null;
        return (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(ScrollCheck, null),
            React__namespace.createElement(Description, { value: schemaNode.annotations.description }),
            React__namespace.createElement(mosaic.HStack, { spacing: 3, pb: 4 },
                React__namespace.createElement(mosaic.Menu, { "aria-label": "Pick a type", closeOnPress: true, placement: "bottom left", items: choices.map((choice, index) => ({
                        id: index,
                        title: choice.title,
                        onPress: () => setSelectedChoice(choice),
                    })), renderTrigger: props => (React__namespace.createElement(mosaic.Pressable, Object.assign({}, props),
                        React__namespace.createElement(mosaic.Flex, { fontFamily: "mono", fontWeight: "semibold", cursor: "pointer", fontSize: "base" },
                            selectedChoice.title,
                            React__namespace.createElement(mosaic.Box, { ml: 1 },
                                React__namespace.createElement(mosaic.Icon, { icon: ['fas', 'caret-down'] }))))) }),
                combiner !== null ? (React__namespace.createElement(mosaic.Flex, { alignItems: "center", color: "muted", fontSize: "base" }, `(${COMBINER_NAME_MAP[combiner]})`)) : null),
            childNodes.length > 0 ? (React__namespace.createElement(ChildStack, { schemaNode: schemaNode, childNodes: childNodes, currentNestingLevel: nestingLevel, parentNodeId: nodeId })) : combiner ? (React__namespace.createElement(SchemaRow, { schemaNode: selectedChoice.type, nestingLevel: nestingLevel })) : null));
    }
    if (isComplexArray(schemaNode) && isPureObjectNode(schemaNode.children[0])) {
        const validations = jsonSchemaTree.isRegularNode(schemaNode) ? getValidationsFromSchema(schemaNode) : {};
        return (React__namespace.createElement(React__namespace.Fragment, null,
            React__namespace.createElement(ScrollCheck, null),
            React__namespace.createElement(Description, { value: schemaNode.annotations.description }),
            React__namespace.createElement(mosaic.Box, { fontFamily: "mono", fontWeight: "semibold", fontSize: "base", pb: 4 }, "array of:"),
            !isEmpty(validations) && (React__namespace.createElement(mosaic.Box, { fontSize: "sm", mb: 1, mt: -2 },
                React__namespace.createElement(Validations, { validations: validations }))),
            childNodes.length > 0 ? (React__namespace.createElement(ChildStack, { schemaNode: schemaNode, childNodes: childNodes, currentNestingLevel: nestingLevel, parentNodeId: nodeId })) : null));
    }
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement(ScrollCheck, null),
        React__namespace.createElement(SchemaRow, { schemaNode: schemaNode, nestingLevel: nestingLevel })));
};
function ScrollCheck() {
    const elementRef = React__namespace.useRef(null);
    const isOnScreen = useIsOnScreen(elementRef);
    const setShowPathCrumbs = utils.useUpdateAtom(showPathCrumbsAtom);
    React__namespace.useEffect(() => {
        setShowPathCrumbs(!isOnScreen);
    }, [isOnScreen, setShowPathCrumbs]);
    return React__namespace.createElement("div", { ref: elementRef });
}
function isPureObjectNode(schemaNode) {
    var _a;
    return schemaNode.primaryType === 'object' && ((_a = schemaNode.types) === null || _a === void 0 ? void 0 : _a.length) === 1 && !isDictionaryNode(schemaNode);
}

const JsonSchemaViewerComponent = (_a) => {
    var { viewMode = 'standalone', defaultExpandedDepth = 1, onGoToRef, renderRowAddon, renderExtensionAddon, hideExamples, renderRootTreeLines, disableCrumbs, nodeHasChanged, skipTopLevelDescription } = _a, rest = __rest(_a, ["viewMode", "defaultExpandedDepth", "onGoToRef", "renderRowAddon", "renderExtensionAddon", "hideExamples", "renderRootTreeLines", "disableCrumbs", "nodeHasChanged", "skipTopLevelDescription"]);
    const options = React__namespace.useMemo(() => ({
        defaultExpandedDepth,
        viewMode,
        onGoToRef,
        renderRowAddon,
        renderExtensionAddon,
        hideExamples,
        renderRootTreeLines,
        disableCrumbs,
        nodeHasChanged,
    }), [
        defaultExpandedDepth,
        viewMode,
        onGoToRef,
        renderRowAddon,
        renderExtensionAddon,
        hideExamples,
        renderRootTreeLines,
        disableCrumbs,
        nodeHasChanged,
    ]);
    return (React__namespace.createElement(mosaic.Provider, null,
        React__namespace.createElement(JSVOptionsContextProvider, { value: options },
            React__namespace.createElement(jotai.Provider, null,
                React__namespace.createElement(JsonSchemaViewerInner, Object.assign({ viewMode: viewMode, skipTopLevelDescription: skipTopLevelDescription }, rest))))));
};
const JsonSchemaViewerInner = ({ schema, viewMode, className, resolveRef, maxRefDepth, emptyText = 'No schema defined', onTreePopulated, maxHeight, parentCrumbs, skipTopLevelDescription, }) => {
    const setHoveredNode = utils.useUpdateAtom(hoveredNodeAtom);
    const onMouseLeave = React__namespace.useCallback(() => {
        setHoveredNode(null);
    }, [setHoveredNode]);
    const { jsonSchemaTreeRoot, nodeCount } = React__namespace.useMemo(() => {
        const jsonSchemaTree$1 = new jsonSchemaTree.SchemaTree(schema, {
            mergeAllOf: true,
            refResolver: resolveRef,
            maxRefDepth,
        });
        let nodeCount = 0;
        jsonSchemaTree$1.walker.hookInto('filter', node => {
            if (shouldNodeBeIncluded(node, viewMode)) {
                nodeCount++;
                return true;
            }
            return false;
        });
        jsonSchemaTree$1.populate();
        return {
            jsonSchemaTreeRoot: jsonSchemaTree$1.root,
            nodeCount,
        };
    }, [schema, resolveRef, maxRefDepth, viewMode]);
    React__namespace.useEffect(() => {
        onTreePopulated === null || onTreePopulated === void 0 ? void 0 : onTreePopulated({
            rootNode: jsonSchemaTreeRoot,
            nodeCount: nodeCount,
        });
    }, [jsonSchemaTreeRoot, onTreePopulated, nodeCount]);
    const isEmpty = React__namespace.useMemo(() => jsonSchemaTreeRoot.children.every(node => !jsonSchemaTree.isRegularNode(node) || node.unknown), [jsonSchemaTreeRoot]);
    if (isEmpty) {
        return (React__namespace.createElement(mosaic.Box, { className: cn(className, 'JsonSchemaViewer'), fontSize: "sm", "data-test": "empty-text" }, emptyText));
    }
    return (React__namespace.createElement(mosaic.Box, { className: cn('JsonSchemaViewer', className), pos: maxHeight ? 'relative' : undefined, overflowY: maxHeight ? 'auto' : undefined, onMouseLeave: onMouseLeave, style: { maxHeight } },
        React__namespace.createElement(PathCrumbs, { parentCrumbs: parentCrumbs }),
        React__namespace.createElement(TopLevelSchemaRow, { schemaNode: jsonSchemaTreeRoot.children[0], skipDescription: skipTopLevelDescription })));
};
const JsonSchemaFallbackComponent = ({ error }) => {
    return (React__namespace.createElement(mosaic.Box, { p: 4 },
        React__namespace.createElement(mosaic.Box, { as: "b", color: "danger" }, "Error"),
        error !== null ? `: ${error.message}` : null));
};
const JsonSchemaViewer = reactErrorBoundary.withErrorBoundary(JsonSchemaViewerComponent, {
    FallbackComponent: JsonSchemaFallbackComponent,
    recoverableProps: ['schema'],
});

exports.JsonSchemaViewer = JsonSchemaViewer;
exports.Validations = Validations;
exports.useChoices = useChoices;
exports.visibleChildren = visibleChildren;
//# sourceMappingURL=index.js.map
