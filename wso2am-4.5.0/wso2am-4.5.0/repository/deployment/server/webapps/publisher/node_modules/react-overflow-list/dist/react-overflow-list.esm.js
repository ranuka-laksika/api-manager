import React from 'react';
import { useShallowCompareEffect, useMount, useUpdateEffect, useMeasure, usePrevious } from 'react-use';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function OverflowList(props) {
  var items = props.items,
      _props$collapseFrom = props.collapseFrom,
      collapseFrom = _props$collapseFrom === void 0 ? 'end' : _props$collapseFrom,
      _props$minVisibleItem = props.minVisibleItems,
      minVisibleItems = _props$minVisibleItem === void 0 ? 0 : _props$minVisibleItem,
      _props$tagName = props.tagName,
      tagName = _props$tagName === void 0 ? 'div' : _props$tagName,
      _props$className = props.className,
      className = _props$className === void 0 ? '' : _props$className,
      _props$alwaysRenderOv = props.alwaysRenderOverflow,
      alwaysRenderOverflow = _props$alwaysRenderOv === void 0 ? false : _props$alwaysRenderOv,
      overflowRenderer = props.overflowRenderer,
      itemRenderer = props.itemRenderer;

  var _React$useState = React.useState({
    visible: items,
    overflow: [],
    lastOverflowCount: 0,
    overflowDirection: 'none'
  }),
      state = _React$useState[0],
      setState = _React$useState[1];

  var spacer = React.useRef(null);
  useShallowCompareEffect(function () {
    repartition(false);
  }, [state]);
  useMount(function () {
    repartition(false);
  });
  useUpdateEffect(function () {
    setState(function () {
      return {
        overflowDirection: 'none',
        lastOverflowCount: 0,
        overflow: [],
        visible: items
      };
    });
  }, [items]);
  var WrapperComponent = tagName;
  var maybeOverflow = state.overflow.length === 0 && !alwaysRenderOverflow ? null : overflowRenderer(state.overflow);

  var repartition = function repartition(growing) {
    if (!spacer.current) {
      return;
    }

    if (growing) {
      setState(function (state) {
        return {
          overflowDirection: 'grow',
          lastOverflowCount: state.overflowDirection === 'none' ? state.overflow.length : state.lastOverflowCount,
          overflow: [],
          visible: props.items
        };
      });
    } else if (spacer.current.getBoundingClientRect().width < 0.9) {
      setState(function (state) {
        if (state.visible.length <= minVisibleItems) {
          return state;
        }

        var collapseFromStart = collapseFrom === 'start';
        var visible = state.visible.slice();
        var next = collapseFromStart ? visible.shift() : visible.pop();

        if (!next) {
          return state;
        }

        var overflow = collapseFromStart ? [].concat(state.overflow, [next]) : [next].concat(state.overflow);
        return _extends({}, state, {
          direction: state.overflowDirection === 'none' ? 'shrink' : state.overflowDirection,
          overflow: overflow,
          visible: visible
        });
      });
    } else {
      setState(function (prevState) {
        return _extends({}, prevState, {
          overflowDirection: 'none'
        });
      });
    }
  };

  var _useMeasure = useMeasure(),
      ref = _useMeasure[0],
      width = _useMeasure[1].width;

  var previousWidth = usePrevious(width);
  React.useEffect(function () {
    if (!previousWidth) return;
    repartition(width > previousWidth);
  }, [width, previousWidth]);
  return React.createElement(WrapperComponent // @ts-ignore
  , {
    // @ts-ignore
    ref: ref,
    className: className,
    style: {
      display: 'flex',
      flexWrap: 'nowrap',
      minWidth: 0
    }
  }, collapseFrom === 'start' ? maybeOverflow : null, state.visible.map(itemRenderer), collapseFrom === 'end' ? maybeOverflow : null, React.createElement("div", {
    style: {
      flexShrink: 1,
      width: 1
    },
    ref: spacer
  }));
}

export { OverflowList };
//# sourceMappingURL=react-overflow-list.esm.js.map
